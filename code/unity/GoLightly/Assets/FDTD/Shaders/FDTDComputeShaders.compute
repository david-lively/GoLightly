/// <remarks>
/// Example Yee grid: domain size is 4 x 4. 
/// ez---hy---ez---hy---ez---hy---ez---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---ez---hy---ez---hy---ez---hy---ez
/// </remarks>
// see https://github.com/david-lively/GoLightly/blob/master/code/GoLightly/GoLightly/Simulator.cu
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSUpdateVisualizerTexture
#pragma kernel CSUpdateEz
#pragma kernel CSUpdateHFields
#pragma kernel CSUpdateSources

#define PI (3.1415926f)
#define ENABLE_PML
// #define MOVING_SOURCE

float4 GameViewTextureSize;
Texture2D<float4> GameViewTexture;
RWTexture2D<float4> VisualizerTexture;

/*
Sample values: 

float lambda = 1.0f;
float eps0 = 1.0f;
float mu0 = 1.0f;
float dx = lambda / 10.f;
float dt = dx / sqrt(2.0f) * 0.95f;
float cbDefault = dt / (eps0 * dx);
float dbDefault = dt / (mu0 * dx);
float ca = 1.0f;
float da = 1.0f;
*/
float2 domainSize;
cbuffer Parameters
{
    float Dt;
    float Dx;
    float Eps0;
    float Mu0;

    float Lambda;

    float Ca;
    float CbDefault;

    float Da;
    float DbDefault;

    int PmlLayers;
}

struct Source
{
    float3 position;
    float amplitude;
    float wavelength;
    float maxLife;
    uint enabled;
};

uint numSources;
StructuredBuffer<Source> sources;

float contrast;
float psiContrast;
int TimeStep;

RWStructuredBuffer<float> ez;
RWStructuredBuffer<float> hx;
RWStructuredBuffer<float> hy;
StructuredBuffer<float> cb;

/*
Decay:
    x -> ezx decay
    y -> ezy decay
    z -> hyx decay
    w -> hxy decay
*/
StructuredBuffer<float4> decay_all;
/*
Psi:
    x -> ezx psi
    y -> ezy psi
    z -> hyx psi
    w -> hxy psi
*/
RWStructuredBuffer<float4> psi_all;

int addr(int x, int y)
{
    return y * domainSize.x + x;
}

int addr(int2 xy)
{
    return addr(xy.x, xy.y);
}

int addr(int3 xy)
{
    return addr(xy.xy);
}

[numthreads(32,32,1)]
void CSUpdateVisualizerTexture (uint3 id : SV_DispatchThreadID)
{
    float4 color = 0;
    int center = addr(id);

    const int x = id.x;
    const int y = id.y;

    color.rgb = saturate(contrast * ez[center]);
    color.a=1;

    // color.g = psiContrast * (abs(ezx_decay[x]));
    // color.b = psiContrast * (abs(ezy_decay[y]));

    float2 gameViewPixelPos = id.xy * GameViewTextureSize.xy / domainSize.xy;
    float4 gameViewColor = GameViewTexture[gameViewPixelPos];
    // blend Ez field with 
    color = (color * 4 + gameViewColor) / 5.0f;        

    VisualizerTexture[id.xy] = color;

}

[numthreads(64,1,1)]
void CSUpdateSources(uint3 id : SV_DispatchThreadID)
{
    // uint count;
    // uint stride;

    if (id.x >= numSources || id.y > 0)
        return;

    Source source = sources[id.x];

    if (!source.enabled || (source.maxLife > 0) && (Dt * TimeStep > source.maxLife))
        return;

    float t = TimeStep * Dt;
    /*
     wavelength (lambda): takes 2*pi time steps to complete one wave
     frequency (nu) = c / wavelength

     freq of 1 == 2*PI in 1/dt time steps 
    
     */
    // float s = source.amplitude * sin(t / source.wavelength);
    float s = source.amplitude * sin(TimeStep * (2 * PI) / (1 / Dt) / source.wavelength);

#ifdef MOVING_SOURCE
    float range = 1000;
    float theta = t/100;
    float dy = (sin(theta) / 2) * range / 2;
    float dx = (cos(theta) / 2) * range;

    source.position.x += dx;
    source.position.y += dy;
#endif

/// ************ WARNING WARNING WARNING WARNING ************ 
/// WARNING: This is a race condition if multiple sources have the same .position value!
    ez[addr(source.position)] += s;
}

/*
/// PML envelope Values
static float e_decay[] = {
    0.133286506,
    0.266546071,
    0.438038647,
    0.616397917,
    0.770144641,
    0.881655931,
    0.9497177,
    0.983808935,
    0.996780813,
    0.999798477
    };

static float h_decay[] = {
    0.193701461,
    0.349247128,
    0.528538823,
    0.697860897,
    0.831596196,
    0.920684338,
    0.970211327,
    0.99215883,
    0.998980284,
    0.999987423     
    };
*/

/// <remarks>
/// Example Yee grid: domain size is 4 x 4. 
/// Ez @ (0,0), size (5x5)
/// Hx @ (0,0), size (5x4)
/// Hy @ (0,0), size (4x5)
/// ez---hy---ez---hy---ez---hy---ez---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---ez---hy---ez---hy---ez---hy---ez
/// </remarks>

/*
Update ranges:
ez : (1,1) - (domainSize.x, domainSize.y)
hx : (0,1) - (domainSize.x, domainSize.y-1)
hy : (1,0) - (domainSize.x-1, domainSize.y)
*/

/*
float4 results:
x -> ezx decay
y -> ezy decay
z -> hyx decay
w -> hxy decay
*/
float4 getDecay(uint2 position)
{
    return decay_all[position.y * domainSize.x + position.x];
}

float4 getPsi(uint2 position)
{
    return psi_all[position.y * domainSize.x + position.x];
}

float getMaterial(uint2 id)
{
    return cb[id.y * domainSize.x + id.x];
/*
    float epsR = 3;
    float material = CbDefault;

    if (id.x > 1024)
        material = Dt / Dx * 1.0 / epsR;

    return material;
*/
}

[numthreads(32,32,1)]
void CSUpdateEz(uint3 id : SV_DispatchThreadID)
{
    /*
    Update range: (1,1)-(w-2,h-2)
    */
    const int x = id.x;
    const int y = id.y;

    if (x < 1 || y < 1 || x >= domainSize.x-1 || y >= domainSize.y - 1)
        return;

    const int center = addr(id.xy);

    float hxBottom = hx[center];
    float hxTop= hx[addr(x,y-1)];

    float hyRight = hy[center];
    float hyLeft = hy[addr(x-1,y)];

    float2 dH = float2(hxBottom-hxTop, hyLeft-hyRight);

    float material = getMaterial(id.xy);


    float ezNew = Ca * ez[addr(id.xy)] + material * (dH.y - dH.x);


    float2 decay = getDecay(id.xy).xy;
    float2 amp = decay - 1;
    float4 psi = psi_all[center];

    psi.y = decay.y * psi.y + amp.y * dH.x;

    ezNew -= material * psi.y;

    psi.x = decay.x * psi.x + amp.x * dH.y;

    psi_all[center] = psi;

    ezNew += material * psi.x;

    ez[addr(id.xy)] = ezNew;
}

[numthreads(32,32,1)]
void CSUpdateHFields(uint3 id : SV_DispatchThreadID)
{
    const uint y = id.y;
    const uint x = id.x;

    if (y >= domainSize.y-2)
        return;

    uint center = addr(id);
    float ezUp = ez[center];
    float ezDown = ez[addr(id.x,id.y+1)];

    float ezLeft = ez[center];
    float ezRight = ez[addr(x+1,y)];

    float2 dEz = float2(ezRight - ezLeft, ezDown - ezUp);

    float newHx = Da * hx[center] - DbDefault * dEz.y;
    float newHy = Da * hy[center] - DbDefault * dEz.x;

    float2 decay = getDecay(id.xy).zw;
    float2 amp = decay - 1;

    float4 psi = psi_all[center];

    psi.z = decay.y * psi.z + amp.y * dEz.y / Dx;
    newHx = newHx - DbDefault * Dx * psi.z;
    psi.w = decay.x * psi.w + amp.x * dEz.x / Dx;
    newHy -= DbDefault * Dx * psi.w;

    psi_all[center] = psi;

    hx[center] = newHx;
    hy[center] = newHy;
}


