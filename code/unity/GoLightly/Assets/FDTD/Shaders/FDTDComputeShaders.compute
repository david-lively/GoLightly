/// <remarks>
/// Example Yee grid: domain size is 4 x 4. 
/// ez---hy---ez---hy---ez---hy---ez---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---ez---hy---ez---hy---ez---hy---ez
/// </remarks>
// see https://github.com/david-lively/GoLightly/blob/master/code/GoLightly/GoLightly/Simulator.cu
// Each #kernel tells which function to compile; you can have many kernels

#pragma kernel CSUpdateVisualizerTexture
#pragma kernel CSUpdateEz
#pragma kernel CSUpdateHFields
#pragma kernel CSUpdateSources
#pragma kernel CSUpdateMonitors

#define PI (3.1415926f)
#define MOVING_SOURCE

RWTexture2D<float4> VisualizerTexture;

/*
Sample values: 

float lambda = 1.0f;
float eps0 = 1.0f;
float mu0 = 1.0f;
float dx = lambda / 10.f;
float dt = dx / sqrt(2.0f) * 0.95f;
float cbDefault = dt / (eps0 * dx);
float dbDefault = dt / (mu0 * dx);
float ca = 1.0f;
float da = 1.0f;
*/
float2 domainSize;
cbuffer Parameters
{
    float Dt;
    float Dx;
    float Eps0;
    float Mu0;

    float Lambda;

    float Ca;
    float CbDefault;

    float Da;
    float DbDefault;

    int PmlLayers;
}

struct Source
{
    float3 position;
    float amplitude;
    float wavelength;
    float maxLife;
    uint enabled;
};

uint numSources;
StructuredBuffer<Source> sources;

float contrast;
float psiContrast;
int TimeStep;

// E field (Z)
RWStructuredBuffer<float> ez;
// H field (X)
RWStructuredBuffer<float> hx;
// H field (y)
RWStructuredBuffer<float> hy;
/* 
Dielectric array. Contains cb component for the Ez domain. 2D stored as a Linear array,
material offset = y * domainWidth + x
*/ 
StructuredBuffer<float> cb;

struct Monitor
{
    int id;
    int offset;
    int len;
};

int numMonitorAddresses;
/*
 List of monitor cells. Since a monitor will typically span multiple Yee cells, we use an
 indirection layer. 
 monitorAddresses<> is a list of linear "2D" offsets into the E or H field array.
 monitorValues contains the read monitor value (RMS) for that location. 
*/

StructuredBuffer<int> monitorAddresses;
RWStructuredBuffer<float> monitorValues;

bool resetRequested;

/*
PML Decay:
    x -> ezx decay
    y -> ezy decay
    z -> hyx decay
    w -> hxy decay
*/
StructuredBuffer<float4> decay_all;
/*
PML Psi:
    x -> ezx psi
    y -> ezy psi
    z -> hyx psi
    w -> hxy psi
*/
RWStructuredBuffer<float4> psi_all;

/// helper method to convert X,Y to linear array offsets
int addr(int x, int y)
{
    return y * domainSize.x + x;
}

/// helper method to convert X,Y to linear array offsets
int addr(int2 xy)
{
    return addr(xy.x, xy.y);
}

/// helper method to convert X,Y to linear array offsets
int addr(int3 xy)
{
    return addr(xy.xy);
}

/// Retrieve the dielectric constant for the given X,Y Yee cell. 
float getMaterial(uint2 id)
{
    return cb[id.y * domainSize.x + id.x];
}


/*
Update a visualizer texture (color buffer) from the Ez field.
*/
[numthreads(32,32,1)]
void CSUpdateVisualizerTexture (uint3 id : SV_DispatchThreadID)
{
    float4 color = 0;
    int center = addr(id);

    const int x = id.x;
    const int y = id.y;

    color.rgb = saturate(contrast * ez[center]);
    color.a=1;

    float4 d = decay_all[center];

    float matRelative = getMaterial(id.xy) / CbDefault;
    if (matRelative != 1)
        color.g += (1-matRelative) * psiContrast;

    //color = (color * 4 + gameViewColor) / 5.0f;        

    // draw the PML layers
    if (any(d < 1))
        color.rgba += (1-d) * psiContrast;

    /* 
    Actually write the color to the texture buffer.
    On the Unity side, this will be blitted to the camera's frame buffer at runtime. 
    */
    VisualizerTexture[id.xy] = color;
}

/// Update any Ez monitors
[numthreads(64,1,1)]
void CSUpdateMonitors(uint3 id : SV_DispatchThreadID)
{
    int index = id.x;
    
    if (index >= numMonitorAddresses)
        return;

    /// Get the ID for the monitor for this thread
    int offset = monitorAddresses[index];
    /// Get the Ez value for this monitor. 
    monitorValues[index] = ez[offset];
    /*
    Those values will be integrated later to get a real value
    for the entire area covered by a given monitor.
    */
}

/* 
Update any source values in the simulation. These are "soft sources,"
so the calculated amplitude is added to the Ez component at the
current source's position.
*/
[numthreads(64,1,1)]
void CSUpdateSources(uint3 id : SV_DispatchThreadID)
{
    // uint count;
    // uint stride;

    if (id.x >= numSources || id.y > 0)
        return;

    Source source = sources[id.x];

    if (!source.enabled || (source.maxLife > 0) && (Dt * TimeStep > source.maxLife))
        return;

    float t = TimeStep * Dt;
    /*
     wavelength (lambda): takes 2*pi time steps to complete one wave
     frequency (nu) = c / wavelength

     freq of 1 == 2*PI in 1/dt time steps 
    
     */
    // float s = source.amplitude * sin(t / source.wavelength);
    // float s = source.amplitude * sin(TimeStep * (2 * PI) / (1 / Dt) / source.wavelength);
    float frequency = 1.f / source.wavelength;
    float s = source.amplitude * sin(t * frequency * 2 * PI);

#ifdef MOVING_SOURCE
    float range = 1000;
    float theta = t/100;
    float dy = (sin(theta) / 2) * range / 2;
    float dx = (cos(theta) / 2) * range;

    source.position.x += dx;
    source.position.y += dy;
#endif

/// ************ WARNING WARNING WARNING WARNING ************ 
/// WARNING: This is a race condition if multiple sources have the same .position value!
    ez[addr(source.position)] += s;
}

/*
/// PML envelope Values
static float e_decay[] = {
    0.133286506,
    0.266546071,
    0.438038647,
    0.616397917,
    0.770144641,
    0.881655931,
    0.9497177,
    0.983808935,
    0.996780813,
    0.999798477
    };

static float h_decay[] = {
    0.193701461,
    0.349247128,
    0.528538823,
    0.697860897,
    0.831596196,
    0.920684338,
    0.970211327,
    0.99215883,
    0.998980284,
    0.999987423     
    };
*/

/// <remarks>
/// Example Yee grid: domain size is 4 x 4. 
/// Ez @ (0,0), size (5x5)
/// Hx @ (0,0), size (5x4)
/// Hy @ (0,0), size (4x5)
/// ez---hy---ez---hy---ez---hy---ez---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---EZ---hy---EZ---hy---EZ---hy---ez
/// |         |         |         |         |         
/// hx        hx        hx        hx        hx
/// |         |         |         |         |         
/// ez---hy---ez---hy---ez---hy---ez---hy---ez
/// </remarks>

/*
Update ranges:
ez : (1,1) - (domainSize.x, domainSize.y)
hx : (0,1) - (domainSize.x, domainSize.y-1)
hy : (1,0) - (domainSize.x-1, domainSize.y)
*/

/*
float4 results:
x -> ezx decay
y -> ezy decay
z -> hyx decay
w -> hxy decay
*/
/// Get the PML decay factor at the given position
float4 getDecay(uint2 position)
{
    return decay_all[position.y * domainSize.x + position.x];
}

/// Get the PML amplification factor at the given position
float4 getPsi(uint2 position)
{
    return psi_all[position.y * domainSize.x + position.x];
}

/*
Update the EZ field based on amp, decay and coupling to Hx and Hy components
at the given Yee cell. 
Ez (t) is a function of Ez (t-1), Hx (t-0.5), Hy (t-0.5). 
Since we can't use 0.5 as an array index, we just use integers. 
*/
[numthreads(32,32,1)]
void CSUpdateEz(uint3 id : SV_DispatchThreadID)
{
    /*
    Update range: (1,1)-(w-2,h-2)
    */
    const int x = id.x;
    const int y = id.y;

    if (x < 1 || y < 1 || x >= domainSize.x-1 || y >= domainSize.y - 1)
        return;

    const int center = addr(id.xy);

    // get the Hx field values in the Y direction. See Taflove. 
    float hxBottom = hx[center];
    float hxTop= hx[addr(x,y-1)];

    // get the Hy field values in the X direction. See Taflove.
    float hyRight = hy[center];
    float hyLeft = hy[addr(x-1,y)];

    /// Calculate the Hx (in Y) and Hy (in X) derivatives surrounding this Ez value
    float2 dH = float2(hxBottom-hxTop, hyLeft-hyRight);

    /// Grab the dielectric value at this Ez location
    float material = getMaterial(id.xy);

    /// Calculate the new Ez value without PML
    float ezNew = Ca * ez[addr(id.xy)] + material * (dH.y - dH.x);

    /*
    PML. Note that the PML fields are stored across the entire domain. This is to support
    PML "sinks," or arbitrarily-shaped PML regions to reduce the number of E and H field components
    that need to be calculated. 
    */
    float2 decay = getDecay(id.xy).xy;
    float2 amp = decay - 1;

    /// Current field value in the PML
    float4 psi = psi_all[center];

    psi.y = decay.y * psi.y + amp.y * dH.x;

    ezNew -= material * psi.y;

    psi.x = decay.x * psi.x + amp.x * dH.y;

    psi_all[center] = psi;

    ezNew += material * psi.x;

    ez[addr(id.xy)] = ezNew;

    /// Hack to allow resetting the field values to zero to restart the simulation
    if (resetRequested)
    {
        ez[addr(id.xy)] = 0;
        psi_all[center] = 0;
    }
}

/* 
Update Hx and Hy components in a single shader pass.
A 3D implementation would have to calculate Hz as well, based on Ex and Ey field values. 
That is left as an excercise for whomever winds up using this code in the future, if any. 
*/
[numthreads(32,32,1)]
void CSUpdateHFields(uint3 id : SV_DispatchThreadID)
{
    const uint y = id.y;
    const uint x = id.x;

    /// bounds check. We can't update H fields without adjacent E field components
    if (y >= domainSize.y-2)
        return;

    uint center = addr(id);
    float ezUp = ez[center];
    float ezDown = ez[addr(id.x,id.y+1)];

    float ezLeft = ez[center];
    float ezRight = ez[addr(x+1,y)];

    float2 dEz = float2(ezRight - ezLeft, ezDown - ezUp);

    float newHx = Da * hx[center] - DbDefault * dEz.y;
    float newHy = Da * hy[center] - DbDefault * dEz.x;

    float2 decay = getDecay(id.xy).zw;
    float2 amp = decay - 1;

    float4 psi = psi_all[center];

    psi.z = decay.y * psi.z + amp.y * dEz.y / Dx;
    newHx = newHx - DbDefault * Dx * psi.z;
    hx[center] = newHx;

    psi.w = decay.x * psi.w + amp.x * dEz.x / Dx;
    newHy -= DbDefault * Dx * psi.w;
    hy[center] = newHy;

    psi_all[center] = psi;

    if (resetRequested)
    {
        hx[center] = 0;
        hy[center] = 0;
        psi_all[center] = 0;
    }
}


