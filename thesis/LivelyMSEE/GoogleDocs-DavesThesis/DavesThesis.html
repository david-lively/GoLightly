<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=n-WUWS8jmQqYQtQ2emmZBw');.lst-kix_uzc3fglvyy7d-0>li:before{content:"-  "}ul.lst-kix_list_1-0{list-style-type:none}.lst-kix_uzc3fglvyy7d-3>li:before{content:"-  "}ol.lst-kix_d4vkpdek3os6-1.start{counter-reset:lst-ctn-kix_d4vkpdek3os6-1 0}.lst-kix_uzc3fglvyy7d-4>li:before{content:"-  "}.lst-kix_uzc3fglvyy7d-6>li:before{content:"-  "}.lst-kix_uzc3fglvyy7d-5>li:before{content:"-  "}.lst-kix_uzc3fglvyy7d-8>li:before{content:"-  "}.lst-kix_uzc3fglvyy7d-7>li:before{content:"-  "}ul.lst-kix_list_1-3{list-style-type:none}ul.lst-kix_list_1-4{list-style-type:none}ul.lst-kix_list_1-1{list-style-type:none}ul.lst-kix_list_1-2{list-style-type:none}ul.lst-kix_list_1-7{list-style-type:none}ul.lst-kix_list_1-8{list-style-type:none}ul.lst-kix_list_1-5{list-style-type:none}ul.lst-kix_list_1-6{list-style-type:none}.lst-kix_iv4q1iy9wb53-1>li{counter-increment:lst-ctn-kix_iv4q1iy9wb53-1}.lst-kix_s4e4d0mvzrbj-4>li{counter-increment:lst-ctn-kix_s4e4d0mvzrbj-4}ol.lst-kix_d4vkpdek3os6-7.start{counter-reset:lst-ctn-kix_d4vkpdek3os6-7 0}.lst-kix_d4vkpdek3os6-4>li{counter-increment:lst-ctn-kix_d4vkpdek3os6-4}ol.lst-kix_iv4q1iy9wb53-8.start{counter-reset:lst-ctn-kix_iv4q1iy9wb53-8 0}ol.lst-kix_s4e4d0mvzrbj-2.start{counter-reset:lst-ctn-kix_s4e4d0mvzrbj-2 0}.lst-kix_iv4q1iy9wb53-3>li{counter-increment:lst-ctn-kix_iv4q1iy9wb53-3}.lst-kix_wtiwhzvdtjo1-7>li{counter-increment:lst-ctn-kix_wtiwhzvdtjo1-7}ol.lst-kix_wtiwhzvdtjo1-0.start{counter-reset:lst-ctn-kix_wtiwhzvdtjo1-0 0}ol.lst-kix_iv4q1iy9wb53-2.start{counter-reset:lst-ctn-kix_iv4q1iy9wb53-2 0}ol.lst-kix_s4e4d0mvzrbj-8.start{counter-reset:lst-ctn-kix_s4e4d0mvzrbj-8 0}.lst-kix_s4e4d0mvzrbj-0>li{counter-increment:lst-ctn-kix_s4e4d0mvzrbj-0}ol.lst-kix_iv4q1iy9wb53-3.start{counter-reset:lst-ctn-kix_iv4q1iy9wb53-3 0}ul.lst-kix_7y1s6xen8as-3{list-style-type:none}ul.lst-kix_7y1s6xen8as-2{list-style-type:none}ul.lst-kix_7y1s6xen8as-5{list-style-type:none}ul.lst-kix_7y1s6xen8as-4{list-style-type:none}ul.lst-kix_7y1s6xen8as-1{list-style-type:none}ol.lst-kix_s4e4d0mvzrbj-7.start{counter-reset:lst-ctn-kix_s4e4d0mvzrbj-7 0}ul.lst-kix_7y1s6xen8as-0{list-style-type:none}.lst-kix_iv4q1iy9wb53-7>li{counter-increment:lst-ctn-kix_iv4q1iy9wb53-7}ul.lst-kix_7y1s6xen8as-7{list-style-type:none}ul.lst-kix_7y1s6xen8as-6{list-style-type:none}ul.lst-kix_7y1s6xen8as-8{list-style-type:none}.lst-kix_d4vkpdek3os6-2>li{counter-increment:lst-ctn-kix_d4vkpdek3os6-2}.lst-kix_d4vkpdek3os6-8>li{counter-increment:lst-ctn-kix_d4vkpdek3os6-8}ol.lst-kix_d4vkpdek3os6-2.start{counter-reset:lst-ctn-kix_d4vkpdek3os6-2 0}.lst-kix_wtiwhzvdtjo1-0>li{counter-increment:lst-ctn-kix_wtiwhzvdtjo1-0}ol.lst-kix_iv4q1iy9wb53-3{list-style-type:none}ol.lst-kix_iv4q1iy9wb53-2{list-style-type:none}ol.lst-kix_iv4q1iy9wb53-1{list-style-type:none}.lst-kix_lpsi3yp6r2f0-6>li:before{content:"\0025cf  "}ol.lst-kix_iv4q1iy9wb53-0{list-style-type:none}ol.lst-kix_iv4q1iy9wb53-7{list-style-type:none}ol.lst-kix_iv4q1iy9wb53-6{list-style-type:none}ol.lst-kix_iv4q1iy9wb53-5{list-style-type:none}ol.lst-kix_iv4q1iy9wb53-4{list-style-type:none}.lst-kix_lpsi3yp6r2f0-8>li:before{content:"\0025a0  "}ol.lst-kix_s4e4d0mvzrbj-0{list-style-type:none}.lst-kix_s4e4d0mvzrbj-8>li{counter-increment:lst-ctn-kix_s4e4d0mvzrbj-8}ol.lst-kix_iv4q1iy9wb53-8{list-style-type:none}ol.lst-kix_s4e4d0mvzrbj-1{list-style-type:none}ol.lst-kix_wtiwhzvdtjo1-1{list-style-type:none}ol.lst-kix_wtiwhzvdtjo1-0{list-style-type:none}ol.lst-kix_wtiwhzvdtjo1-3{list-style-type:none}ol.lst-kix_wtiwhzvdtjo1-2{list-style-type:none}ol.lst-kix_wtiwhzvdtjo1-1.start{counter-reset:lst-ctn-kix_wtiwhzvdtjo1-1 0}ol.lst-kix_iv4q1iy9wb53-6.start{counter-reset:lst-ctn-kix_iv4q1iy9wb53-6 0}.lst-kix_wtiwhzvdtjo1-2>li{counter-increment:lst-ctn-kix_wtiwhzvdtjo1-2}.lst-kix_7y1s6xen8as-3>li:before{content:"-  "}ul.lst-kix_lpsi3yp6r2f0-0{list-style-type:none}.lst-kix_iv4q1iy9wb53-6>li:before{content:"" counter(lst-ctn-kix_iv4q1iy9wb53-0,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-1,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-2,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-3,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-4,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-5,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-6,decimal) ". "}ol.lst-kix_d4vkpdek3os6-0.start{counter-reset:lst-ctn-kix_d4vkpdek3os6-0 0}.lst-kix_7y1s6xen8as-1>li:before{content:"-  "}ul.lst-kix_lpsi3yp6r2f0-6{list-style-type:none}ol.lst-kix_s4e4d0mvzrbj-2{list-style-type:none}ul.lst-kix_lpsi3yp6r2f0-5{list-style-type:none}ol.lst-kix_s4e4d0mvzrbj-3{list-style-type:none}.lst-kix_iv4q1iy9wb53-6>li{counter-increment:lst-ctn-kix_iv4q1iy9wb53-6}ul.lst-kix_lpsi3yp6r2f0-8{list-style-type:none}ol.lst-kix_s4e4d0mvzrbj-4{list-style-type:none}ul.lst-kix_lpsi3yp6r2f0-7{list-style-type:none}ol.lst-kix_s4e4d0mvzrbj-5{list-style-type:none}ul.lst-kix_lpsi3yp6r2f0-2{list-style-type:none}ol.lst-kix_s4e4d0mvzrbj-6{list-style-type:none}ul.lst-kix_lpsi3yp6r2f0-1{list-style-type:none}ol.lst-kix_s4e4d0mvzrbj-7{list-style-type:none}.lst-kix_iv4q1iy9wb53-8>li:before{content:"" counter(lst-ctn-kix_iv4q1iy9wb53-0,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-1,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-2,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-3,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-4,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-5,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-6,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-7,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-8,decimal) ". "}ul.lst-kix_lpsi3yp6r2f0-4{list-style-type:none}ol.lst-kix_s4e4d0mvzrbj-8{list-style-type:none}ul.lst-kix_lpsi3yp6r2f0-3{list-style-type:none}.lst-kix_7y1s6xen8as-7>li:before{content:"-  "}.lst-kix_7y1s6xen8as-5>li:before{content:"-  "}.lst-kix_wtiwhzvdtjo1-1>li{counter-increment:lst-ctn-kix_wtiwhzvdtjo1-1}.lst-kix_iv4q1iy9wb53-5>li{counter-increment:lst-ctn-kix_iv4q1iy9wb53-5}.lst-kix_iv4q1iy9wb53-4>li:before{content:"" counter(lst-ctn-kix_iv4q1iy9wb53-0,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-1,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-2,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-3,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-4,decimal) ". "}.lst-kix_list_1-1>li:before{content:"\0025cb  "}.lst-kix_iv4q1iy9wb53-2>li:before{content:"" counter(lst-ctn-kix_iv4q1iy9wb53-0,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-1,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-2,decimal) ". "}.lst-kix_list_1-3>li:before{content:"\0025a0  "}.lst-kix_wtiwhzvdtjo1-8>li{counter-increment:lst-ctn-kix_wtiwhzvdtjo1-8}.lst-kix_iv4q1iy9wb53-0>li:before{content:"" counter(lst-ctn-kix_iv4q1iy9wb53-0,decimal) ". "}ol.lst-kix_wtiwhzvdtjo1-5{list-style-type:none}.lst-kix_list_1-7>li:before{content:"\0025a0  "}ol.lst-kix_wtiwhzvdtjo1-4{list-style-type:none}ol.lst-kix_wtiwhzvdtjo1-7{list-style-type:none}ol.lst-kix_wtiwhzvdtjo1-6{list-style-type:none}.lst-kix_list_1-5>li:before{content:"\0025a0  "}ol.lst-kix_wtiwhzvdtjo1-8{list-style-type:none}.lst-kix_lpsi3yp6r2f0-0>li:before{content:"\0025cf  "}.lst-kix_lpsi3yp6r2f0-2>li:before{content:"\0025a0  "}.lst-kix_s4e4d0mvzrbj-2>li{counter-increment:lst-ctn-kix_s4e4d0mvzrbj-2}.lst-kix_uzc3fglvyy7d-2>li:before{content:"-  "}ol.lst-kix_iv4q1iy9wb53-7.start{counter-reset:lst-ctn-kix_iv4q1iy9wb53-7 0}.lst-kix_lpsi3yp6r2f0-4>li:before{content:"\0025cb  "}ol.lst-kix_wtiwhzvdtjo1-8.start{counter-reset:lst-ctn-kix_wtiwhzvdtjo1-8 0}.lst-kix_d4vkpdek3os6-8>li:before{content:"" counter(lst-ctn-kix_d4vkpdek3os6-8,lower-roman) ". "}.lst-kix_d4vkpdek3os6-3>li{counter-increment:lst-ctn-kix_d4vkpdek3os6-3}.lst-kix_d4vkpdek3os6-7>li:before{content:"" counter(lst-ctn-kix_d4vkpdek3os6-7,lower-latin) ". "}ol.lst-kix_iv4q1iy9wb53-5.start{counter-reset:lst-ctn-kix_iv4q1iy9wb53-5 0}.lst-kix_iv4q1iy9wb53-2>li{counter-increment:lst-ctn-kix_iv4q1iy9wb53-2}.lst-kix_s4e4d0mvzrbj-3>li{counter-increment:lst-ctn-kix_s4e4d0mvzrbj-3}.lst-kix_d4vkpdek3os6-1>li:before{content:"" counter(lst-ctn-kix_d4vkpdek3os6-1,lower-latin) ". "}.lst-kix_d4vkpdek3os6-2>li:before{content:"" counter(lst-ctn-kix_d4vkpdek3os6-2,lower-roman) ". "}.lst-kix_d4vkpdek3os6-3>li:before{content:"" counter(lst-ctn-kix_d4vkpdek3os6-3,decimal) ". "}.lst-kix_d4vkpdek3os6-4>li:before{content:"" counter(lst-ctn-kix_d4vkpdek3os6-4,lower-latin) ". "}.lst-kix_d4vkpdek3os6-6>li:before{content:"" counter(lst-ctn-kix_d4vkpdek3os6-6,decimal) ". "}.lst-kix_d4vkpdek3os6-5>li:before{content:"" counter(lst-ctn-kix_d4vkpdek3os6-5,lower-roman) ". "}.lst-kix_wtiwhzvdtjo1-6>li:before{content:"" counter(lst-ctn-kix_wtiwhzvdtjo1-0,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-1,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-2,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-3,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-4,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-5,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-6,decimal) ". "}.lst-kix_wtiwhzvdtjo1-7>li:before{content:"" counter(lst-ctn-kix_wtiwhzvdtjo1-0,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-1,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-2,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-3,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-4,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-5,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-6,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-7,decimal) ". "}.lst-kix_s4e4d0mvzrbj-1>li{counter-increment:lst-ctn-kix_s4e4d0mvzrbj-1}.lst-kix_wtiwhzvdtjo1-4>li:before{content:"" counter(lst-ctn-kix_wtiwhzvdtjo1-0,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-1,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-2,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-3,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-4,decimal) ". "}.lst-kix_wtiwhzvdtjo1-8>li:before{content:"" counter(lst-ctn-kix_wtiwhzvdtjo1-0,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-1,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-2,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-3,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-4,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-5,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-6,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-7,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-8,decimal) ". "}ol.lst-kix_s4e4d0mvzrbj-5.start{counter-reset:lst-ctn-kix_s4e4d0mvzrbj-5 0}.lst-kix_d4vkpdek3os6-1>li{counter-increment:lst-ctn-kix_d4vkpdek3os6-1}.lst-kix_wtiwhzvdtjo1-5>li:before{content:"" counter(lst-ctn-kix_wtiwhzvdtjo1-0,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-1,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-2,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-3,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-4,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-5,decimal) ". "}ol.lst-kix_d4vkpdek3os6-4.start{counter-reset:lst-ctn-kix_d4vkpdek3os6-4 0}.lst-kix_iv4q1iy9wb53-0>li{counter-increment:lst-ctn-kix_iv4q1iy9wb53-0}.lst-kix_wtiwhzvdtjo1-0>li:before{content:"" counter(lst-ctn-kix_wtiwhzvdtjo1-0,decimal) ". "}.lst-kix_wtiwhzvdtjo1-2>li:before{content:"" counter(lst-ctn-kix_wtiwhzvdtjo1-0,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-1,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-2,decimal) ". "}.lst-kix_wtiwhzvdtjo1-3>li:before{content:"" counter(lst-ctn-kix_wtiwhzvdtjo1-0,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-1,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-2,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-3,decimal) ". "}.lst-kix_wtiwhzvdtjo1-1>li:before{content:"" counter(lst-ctn-kix_wtiwhzvdtjo1-0,decimal) "." counter(lst-ctn-kix_wtiwhzvdtjo1-1,decimal) ". "}ul.lst-kix_uzc3fglvyy7d-5{list-style-type:none}ol.lst-kix_wtiwhzvdtjo1-3.start{counter-reset:lst-ctn-kix_wtiwhzvdtjo1-3 0}ul.lst-kix_uzc3fglvyy7d-4{list-style-type:none}ul.lst-kix_uzc3fglvyy7d-7{list-style-type:none}ul.lst-kix_uzc3fglvyy7d-6{list-style-type:none}ul.lst-kix_uzc3fglvyy7d-8{list-style-type:none}ol.lst-kix_s4e4d0mvzrbj-6.start{counter-reset:lst-ctn-kix_s4e4d0mvzrbj-6 0}.lst-kix_s4e4d0mvzrbj-6>li:before{content:"" counter(lst-ctn-kix_s4e4d0mvzrbj-0,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-1,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-2,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-3,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-4,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-5,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-6,decimal) ". "}.lst-kix_s4e4d0mvzrbj-8>li:before{content:"" counter(lst-ctn-kix_s4e4d0mvzrbj-0,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-1,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-2,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-3,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-4,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-5,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-6,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-7,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-8,decimal) ". "}ul.lst-kix_uzc3fglvyy7d-1{list-style-type:none}ul.lst-kix_uzc3fglvyy7d-0{list-style-type:none}ul.lst-kix_uzc3fglvyy7d-3{list-style-type:none}ul.lst-kix_uzc3fglvyy7d-2{list-style-type:none}.lst-kix_s4e4d0mvzrbj-7>li:before{content:"" counter(lst-ctn-kix_s4e4d0mvzrbj-0,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-1,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-2,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-3,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-4,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-5,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-6,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-7,decimal) ". "}.lst-kix_s4e4d0mvzrbj-4>li:before{content:"" counter(lst-ctn-kix_s4e4d0mvzrbj-0,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-1,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-2,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-3,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-4,decimal) ". "}ol.lst-kix_d4vkpdek3os6-3.start{counter-reset:lst-ctn-kix_d4vkpdek3os6-3 0}.lst-kix_iv4q1iy9wb53-4>li{counter-increment:lst-ctn-kix_iv4q1iy9wb53-4}.lst-kix_s4e4d0mvzrbj-5>li:before{content:"" counter(lst-ctn-kix_s4e4d0mvzrbj-0,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-1,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-2,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-3,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-4,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-5,decimal) ". "}.lst-kix_s4e4d0mvzrbj-0>li:before{content:"" counter(lst-ctn-kix_s4e4d0mvzrbj-0,decimal) ". "}ol.lst-kix_s4e4d0mvzrbj-0.start{counter-reset:lst-ctn-kix_s4e4d0mvzrbj-0 0}ol.lst-kix_wtiwhzvdtjo1-2.start{counter-reset:lst-ctn-kix_wtiwhzvdtjo1-2 0}.lst-kix_s4e4d0mvzrbj-7>li{counter-increment:lst-ctn-kix_s4e4d0mvzrbj-7}.lst-kix_s4e4d0mvzrbj-3>li:before{content:"" counter(lst-ctn-kix_s4e4d0mvzrbj-0,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-1,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-2,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-3,decimal) ". "}.lst-kix_s4e4d0mvzrbj-2>li:before{content:"" counter(lst-ctn-kix_s4e4d0mvzrbj-0,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-1,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-2,decimal) ". "}.lst-kix_s4e4d0mvzrbj-1>li:before{content:"" counter(lst-ctn-kix_s4e4d0mvzrbj-0,decimal) "." counter(lst-ctn-kix_s4e4d0mvzrbj-1,decimal) ". "}.lst-kix_d4vkpdek3os6-5>li{counter-increment:lst-ctn-kix_d4vkpdek3os6-5}.lst-kix_d4vkpdek3os6-0>li:before{content:"" counter(lst-ctn-kix_d4vkpdek3os6-0,decimal) ". "}ol.lst-kix_iv4q1iy9wb53-4.start{counter-reset:lst-ctn-kix_iv4q1iy9wb53-4 0}.lst-kix_wtiwhzvdtjo1-3>li{counter-increment:lst-ctn-kix_wtiwhzvdtjo1-3}.lst-kix_wtiwhzvdtjo1-6>li{counter-increment:lst-ctn-kix_wtiwhzvdtjo1-6}.lst-kix_iv4q1iy9wb53-8>li{counter-increment:lst-ctn-kix_iv4q1iy9wb53-8}.lst-kix_lpsi3yp6r2f0-7>li:before{content:"\0025cb  "}ol.lst-kix_d4vkpdek3os6-8.start{counter-reset:lst-ctn-kix_d4vkpdek3os6-8 0}ol.lst-kix_s4e4d0mvzrbj-1.start{counter-reset:lst-ctn-kix_s4e4d0mvzrbj-1 0}.lst-kix_wtiwhzvdtjo1-4>li{counter-increment:lst-ctn-kix_wtiwhzvdtjo1-4}ol.lst-kix_wtiwhzvdtjo1-4.start{counter-reset:lst-ctn-kix_wtiwhzvdtjo1-4 0}ol.lst-kix_s4e4d0mvzrbj-4.start{counter-reset:lst-ctn-kix_s4e4d0mvzrbj-4 0}.lst-kix_wtiwhzvdtjo1-5>li{counter-increment:lst-ctn-kix_wtiwhzvdtjo1-5}.lst-kix_7y1s6xen8as-0>li:before{content:"-  "}.lst-kix_d4vkpdek3os6-7>li{counter-increment:lst-ctn-kix_d4vkpdek3os6-7}ol.lst-kix_wtiwhzvdtjo1-7.start{counter-reset:lst-ctn-kix_wtiwhzvdtjo1-7 0}.lst-kix_7y1s6xen8as-2>li:before{content:"-  "}.lst-kix_iv4q1iy9wb53-5>li:before{content:"" counter(lst-ctn-kix_iv4q1iy9wb53-0,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-1,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-2,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-3,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-4,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-5,decimal) ". "}.lst-kix_iv4q1iy9wb53-7>li:before{content:"" counter(lst-ctn-kix_iv4q1iy9wb53-0,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-1,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-2,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-3,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-4,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-5,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-6,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-7,decimal) ". "}.lst-kix_7y1s6xen8as-6>li:before{content:"-  "}.lst-kix_7y1s6xen8as-8>li:before{content:"-  "}.lst-kix_s4e4d0mvzrbj-6>li{counter-increment:lst-ctn-kix_s4e4d0mvzrbj-6}.lst-kix_7y1s6xen8as-4>li:before{content:"-  "}.lst-kix_d4vkpdek3os6-0>li{counter-increment:lst-ctn-kix_d4vkpdek3os6-0}.lst-kix_s4e4d0mvzrbj-5>li{counter-increment:lst-ctn-kix_s4e4d0mvzrbj-5}ol.lst-kix_iv4q1iy9wb53-0.start{counter-reset:lst-ctn-kix_iv4q1iy9wb53-0 0}.lst-kix_d4vkpdek3os6-6>li{counter-increment:lst-ctn-kix_d4vkpdek3os6-6}.lst-kix_iv4q1iy9wb53-3>li:before{content:"" counter(lst-ctn-kix_iv4q1iy9wb53-0,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-1,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-2,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-3,decimal) ". "}.lst-kix_list_1-0>li:before{content:"\0025cf  "}ol.lst-kix_wtiwhzvdtjo1-6.start{counter-reset:lst-ctn-kix_wtiwhzvdtjo1-6 0}ol.lst-kix_d4vkpdek3os6-6.start{counter-reset:lst-ctn-kix_d4vkpdek3os6-6 0}.lst-kix_iv4q1iy9wb53-1>li:before{content:"" counter(lst-ctn-kix_iv4q1iy9wb53-0,decimal) "." counter(lst-ctn-kix_iv4q1iy9wb53-1,decimal) ". "}.lst-kix_list_1-2>li:before{content:"\0025a0  "}ol.lst-kix_d4vkpdek3os6-7{list-style-type:none}.lst-kix_list_1-4>li:before{content:"\0025a0  "}ol.lst-kix_d4vkpdek3os6-8{list-style-type:none}ol.lst-kix_d4vkpdek3os6-5{list-style-type:none}ol.lst-kix_d4vkpdek3os6-6{list-style-type:none}ol.lst-kix_d4vkpdek3os6-3{list-style-type:none}ol.lst-kix_iv4q1iy9wb53-1.start{counter-reset:lst-ctn-kix_iv4q1iy9wb53-1 0}ol.lst-kix_d4vkpdek3os6-4{list-style-type:none}ol.lst-kix_d4vkpdek3os6-1{list-style-type:none}ol.lst-kix_d4vkpdek3os6-2{list-style-type:none}ol.lst-kix_d4vkpdek3os6-0{list-style-type:none}.lst-kix_list_1-6>li:before{content:"\0025a0  "}.lst-kix_lpsi3yp6r2f0-1>li:before{content:"\0025cb  "}ol.lst-kix_s4e4d0mvzrbj-3.start{counter-reset:lst-ctn-kix_s4e4d0mvzrbj-3 0}ol.lst-kix_wtiwhzvdtjo1-5.start{counter-reset:lst-ctn-kix_wtiwhzvdtjo1-5 0}.lst-kix_lpsi3yp6r2f0-3>li:before{content:"\0025cf  "}ol.lst-kix_d4vkpdek3os6-5.start{counter-reset:lst-ctn-kix_d4vkpdek3os6-5 0}.lst-kix_lpsi3yp6r2f0-5>li:before{content:"\0025a0  "}.lst-kix_list_1-8>li:before{content:"\0025a0  "}.lst-kix_uzc3fglvyy7d-1>li:before{content:"-  "}ol{margin:0;padding:0}table td,table th{padding:0}.c40{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c29{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:234pt;border-top-color:#000000;border-bottom-style:solid}.c2{color:#000000;font-weight:normal;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Verdana";font-style:normal}.c0{color:#000000;font-weight:normal;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c26{color:#000000;font-weight:normal;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c13{color:#000000;font-weight:normal;text-decoration:none;vertical-align:baseline;font-family:"Verdana";font-style:normal}.c12{border-spacing:0;border-collapse:collapse;margin-right:auto}.c14{margin-left:4.5pt;padding-top:4.5pt;padding-bottom:4.5pt;margin-right:4.5pt}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c27{font-size:12pt;font-family:"Garamond";color:#00467f}.c16{padding-top:5pt;padding-bottom:5pt;margin-right:5pt}.c34{font-size:12pt;color:#00467f;font-weight:bold}.c38{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c15{padding-top:0pt;padding-bottom:6pt;line-height:1.2999999523162842}.c4{padding-top:0pt;padding-bottom:0pt}.c20{margin-left:72pt;padding-left:0pt}.c5{color:#1155cc;text-decoration:underline}.c39{width:33%;height:1px}.c17{color:#999999;font-size:8pt}.c36{padding-top:0pt;padding-bottom:4pt}.c41{padding-top:0pt;padding-bottom:10pt}.c7{border:1px solid black;margin:5px}.c42{padding-top:0pt;padding-bottom:8pt}.c6{margin-left:36pt;padding-left:0pt}.c8{color:inherit;text-decoration:inherit}.c32{padding:0;margin:0}.c19{font-family:"Courier New"}.c37{font-weight:bold}.c9{height:10pt}.c22{color:#ff0000}.c18{height:12pt}.c24{font-style:italic}.c33{color:#262626}.c11{margin-left:36pt}.c28{margin-left:18pt}.c23{height:0pt}.c21{text-align:left}.c10{font-size:14pt}.c30{font-size:18pt}.c3{text-align:center}.c31{margin-left:54pt}.c35{padding-bottom:18pt}.c25{line-height:1.2999999523162842}.title{padding-top:24pt;color:#000000;font-weight:bold;font-size:36pt;padding-bottom:6pt;font-family:"Verdana";line-height:1.0;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.0;font-style:italic;text-align:left}li{color:#000000;font-size:10pt;font-family:"Verdana"}p{margin:0;color:#000000;font-size:10pt;font-family:"Verdana"}h1{padding-top:18pt;color:#00467f;font-weight:bold;font-size:12pt;padding-bottom:0pt;font-family:"Verdana";line-height:1.0;text-align:left}h2{padding-top:18pt;color:#00467f;font-weight:bold;font-size:12pt;padding-bottom:0pt;font-family:"Verdana";line-height:1.0;text-align:left}h3{padding-top:18pt;color:#00467f;font-weight:bold;font-size:12pt;padding-bottom:0pt;font-family:"Verdana";line-height:1.0;text-align:left}h4{padding-top:12.8pt;color:#000000;font-weight:bold;font-size:10pt;padding-bottom:12.8pt;font-family:"Verdana";line-height:1.0;text-align:left}h5{padding-top:12.8pt;color:#000000;font-weight:bold;font-size:8pt;padding-bottom:12.8pt;font-family:"Verdana";line-height:1.0;text-align:left}h6{padding-top:18pt;color:#000000;font-weight:bold;font-size:8pt;padding-bottom:18pt;font-family:"Verdana";line-height:1.0;text-align:left}</style></head><body class="c38"><p class="c3 c35 title" id="h.bew160z8y394"><span class="c10">Implementation of the Finite Difference Time Domain Method on Graphics Processing Units using CUDA</span></p><p class="c3"><span>S. David Lively</span></p><p class="c3"><span>March 2016</span></p><p><span></span></p><h1 class="c3 c42" id="h.yxr4q450h6r4"><span>Abstract</span></h1><p><span>Traditionally, optical circuit design is tested and validated using software which implement numerical modeling techniques such as Beam Propagation, Finite Element Analysis and </span><span>FDTD</span><sup><a href="#ftnt1" id="ftnt_ref1">[1]</a></sup><span>. </span></p><p><span>While effective and accurate, FDTD simulations require significant computational power. Existing installations may distribute the computational requirements across large clusters of high-powered servers. This approach entails significant expense in terms of hardware, staffing and software support which may be prohibitive for some research facilities and private-sector engineering firms. </span></p><p><span>Application of modern programmable GPGPUs</span><sup><a href="#ftnt2" id="ftnt_ref2">[2]</a></sup><span>&nbsp;to problems in scientific visualization and computation has facilitated dramatically accelerated development cycles for a variety of industry segments including large dataset visualization, microprocessor design, aerospace and electromagnetic wave propagation in the context of optical circuit design.</span></p><p><span>The FDTD algorithm as envisioned by its creators maps well to the massively-multithreaded data-parallel nature of GPUs. This thesis explores a GPU FDTD implementation and details performance gains, limitations of the GPU approach, optimization techniques and potential future enhancements that may provide even greater benefits from this underutilized</span><span>&nbsp;and often-overlooked tool. </span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><hr style="page-break-before:always;display:none;"><p><span></span></p><h1 class="c3" id="h.z2aq2tlff8iu"><span>Declaration</span></h1><p><span>The work in this thesis is based on research carried out in the Department of Electrical Engineering, Southern Methodist University, Dallas, Texas, USA. No part of this thesis has been submitted elsewhere for any other degree or qualification and comprises original work unless otherwise explicitly stated within the text. </span></p><p><span></span></p><p><span>Copyright &copy; 2016 by S. David Lively</span></p><p><span></span></p><hr style="page-break-before:always;display:none;"><p><span></span></p><h1 class="c3" id="h.ocn2sss3c15x"><span>Table of Contents</span><sup><a href="#cmnt1" id="cmnt_ref1">[a]</a></sup></h1><p><span></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.yxr4q450h6r4">Abstract</a></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.z2aq2tlff8iu">Declaration</a></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.ocn2sss3c15x">Table of Contents</a></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.vxvfm2g67t7l">Introduction</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.c69d0n5hvl0x">Background</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.4wdoz6onfg5r">Overview of FDTD</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.ht5xrt6nbx6d">Applications</a></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.myuyxkr0zdpx">Existing Solutions</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.sqw6ea69zd9z">Meep (Massachusetts Institute of Technology)</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.6hjaryrm9bhx">Problems with Existing Solutions</a></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.pl8gzqmqhr1z">Device Architecture</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.5n775691jlv4">CPU</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.7h886cyymjz6">GPU</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.gopaxnobw6p4">Summary</a></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.xo10qdm1djfq">Design Goals</a></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.ql03opfhtmu6">Implementation</a></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.fr25zcpx0r4o">Results</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.f2gnbl9h7e4l">Test Model Configuration</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.m8g0fnu5fwk6">Testing Methodology</a></span></p><p class="c31"><span class="c5"><a class="c8" href="#h.o2i3awhojasy">Validation</a></span></p><p class="c31"><span class="c5"><a class="c8" href="#h.qtfbr0gx5o46">Analytical Result</a></span></p><p class="c31"><span class="c5"><a class="c8" href="#h.444sb8v67ypi">Numerical Result</a></span></p><p class="c11"><span class="c5"><a class="c8" href="#h.45n5ld8ynbzb">Performance</a></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.41kzd4vlq6o2">Future Work</a></span></p><p class="c28"><span class="c5"><a class="c8" href="#h.ta42bg8umuhq">Conclusions</a></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><hr style="page-break-before:always;display:none;"><p><span></span></p><h1 id="h.vxvfm2g67t7l"><span>Introduction</span></h1><h2 id="h.c69d0n5hvl0x"><span>Background</span></h2><p><span></span></p><p class="c16"><span>FDTD requires </span><span>trivial amounts of work for a given point within a problem domain (&ldquo;simulation space&rdquo;). However, any interesting problem will require a large domain, requiring significant processor power and time. </span></p><p class="c16"><span>GPGPU</span><span>&nbsp;programming is a growing field finding adoption in many areas, from the scientific and engineering communities to the financial sector. GPUs provide large arrays of processing cores with somewhat limited processing </span><span>power</span><span>. </span></p><p class="c16"><span>A fast, GPU-based FDTD tool enables engineers and researchers to iterate designs faster than ever, approaching interactive speeds in some cases. This allows designers to reduce time-to-market for any new product, explore potential research areas that may otherwise have required large computational support such as HPC clusters, and close the iterative design loop. </span></p><h2 class="c16 c18" id="h.vfazhsto571l"><span></span></h2><h2 class="c16" id="h.4wdoz6onfg5r"><span>Overview of FDTD</span></h2><p><span>A canonical FDTD implementation works by maintaining parallel arrays describing the electromagnetic state of the problem domain, and updating these fields in an alternating fashion to simulate the propagation of waves. This section describes that process.</span></p><p><span></span></p><p><span>The original FDTD algorithm as described by Yee begins by creating an array of so-called &ldquo;Yee cells.&rdquo; </span></p><p><span></span></p><p><span>A cell is a description of the electromagnetic state of a given point in the simulation space, containing electric and magnetic field intensities, as well as material properties of the location in question. </span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 498.67px;"><img alt="sketch_Yee.jpg" src="images/image46.jpg" style="width: 624.00px; height: 498.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><sup><a href="#cmnt2" id="cmnt_ref2">[b]</a></sup><sup><a href="#cmnt3" id="cmnt_ref3">[c]</a></sup></p><p class="c3"><span>Yee cell for a 2D TMz simulation </span></p><p><span></span></p><p><span>As can be seen in this image, each cell maintains electric field values at a given location, as well as the coupled magnetic field values at adjacent &ldquo;half locations.&rdquo; In practice, the underlying data structures describe an interlaced field of electric and magnetic fields connected in a mesh, with a magnetic field value placed between each electric field value.</span></p><p><span></span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 589.50px; height: 434.00px;"><img alt="" src="images/image49.jpg" style="width: 589.50px; height: 434.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span>Yee mesh for 2D TMz simulation</span></p><p><span></span></p><p><span>FDTD describes a system where, for a given time step, one set of fields - electric or magnetic - are updated based on the value of their coupled fields at adjacent locations within the simulation space. Once all fields of a given type - electric or magnetic - are updated, the coupled fields are updated given the values calculated in the previous step. </span></p><p><span></span></p><p><span>This iterative process may be summarized as follows:</span></p><ol class="c32 lst-kix_s4e4d0mvzrbj-0 start" start="1"><li class="c6"><span>Update each E field component in the simulation space using the adjacent H field values</span></li><li class="c6"><span>Update each H field component using the adjacent E field values calculated in the previous step.</span></li><li class="c6"><span>Update the current E field to reflect activity of any E or H </span><span class="c37">sources</span><span>&nbsp;within the simulation space. (For example, modulating the amplitude of a point source to simulate a sinusoidal amplitude delta to simulate a monochromatic light source).</span></li><li class="c6"><span>Repeat all steps until an exit condition is reached. </span></li></ol><p><span></span></p><p><span>Individual field components are updated using their previous value and coefficients describing material properties as well as spatial and temporal distance between adjacent grid cells and frames. For two-dimensional simulations, these are calculated during the initialization phase using the following formulae:</span></p><p class="c3"><img src="images/image00.png"></p><p><span>For a simulation to remain stable, the smallest permissible spatial step is, at most, one-tenth of the source wavelength. The simulated time step may be expressed as the ratio of </span><img src="images/image01.png"><span>to the root of the dimensionality of the simulation. </span></p><p><span></span></p><p><span>At each half time step (&ldquo;frame&rdquo;), cells are updated using a combination of the cell&rsquo;s existing state (EM values from the previous frame), dielectric media properties, and adjacent orthogonal coupled field values using the following formulae. (For simplicity, only the equations for a 2D TMz simulation are included here.) </span></p><p class="c3"><img></p><p><span>Where </span></p><p><span></span></p><a id="t.1b566bb22e942ad6ec6d9d55f9e13be20420b4fd"></a><a id="t.0"></a><table class="c12"><tbody><tr class="c23"><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">i,j</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span>Grid location of this cell. Electric and magnetic cell centers are offset by </span><img src="images/image02.png"><span class="c2">)</span></p></td></tr><tr class="c23"><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">t</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Time step. A single time step requires both an E and H field update.</span></p></td></tr><tr class="c23"><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Ez</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Electric field amplitude in Z</span></p></td></tr><tr class="c23"><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Hx</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Magnetic field amplitude in X</span></p></td></tr><tr class="c23"><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Hy</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Magnetic field amplitude in Y</span></p></td></tr><tr class="c23"><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Ca</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">1 for lossless media</span></p></td></tr><tr class="c23"><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Cb</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><img src="images/image03.png"></p></td></tr></tbody></table><p><span></span></p><p><span>Magnetic fields are calculated using the formulae:</span></p><p class="c3"><img src="images/image04.png"></p><p class="c3"><img src="images/image05.png"></p><p><span class="c30"></span></p><p><span></span></p><a id="t.fad530d18ad0bd2537878d67e8ffa638f2923858"></a><a id="t.1"></a><table class="c12"><tbody><tr class="c23"><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Da</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">1 for lossless media</span></p></td></tr><tr class="c23"><td class="c29" colspan="1" rowspan="1"><p class="c1"><span class="c2">Db</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c1"><img src="images/image06.png"></p></td></tr></tbody></table><p><span></span></p><p><span>Media are typically defined in terms of relative electrical permittivity </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 12.00px; height: 8.00px;"><img alt="" src="images/image52.gif" style="width: 12.00px; height: 8.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>&nbsp;and magnetic permeability </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 16.00px; height: 9.33px;"><img alt="" src="images/image51.gif" style="width: 16.00px; height: 9.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>. The FDTD media coefficients are defined in terms of those values (assuming a uniform grid with equal spatial and temporal step sizes in X and Y)</span></p><p><span></span></p><p><span>At each time step, each field value is changed by adding the derivative of the orthogonal, coupled field, scaled by the permittivity or permeability of the medium. The E field receives a scaled portion of the adjacent magnetic field proportional to the local magnetic flux, as represented by the local field slope in the relevant direction. The H fields receive a portion of the E field, proportional to the local electric flux. </span></p><p><span class="c22 c24"></span></p><p><span>The concept of a &ldquo;half step&rdquo; in time is fundamental to FDTD. In order to effectively simulate the interaction of electric and magnetic fields in a way that accurately portrays the propagation of a wave in space, FDTD requires that E and H fields are updated simultaneously at a given point in simulation time. </span></p><p><span>However, since each field update depends on the adjacent orthogonal fields, this is not possible. Thus, for a given time t, FDTD updates each E field given the current electromagnetic state of the domain. H fields are then updated assuming that simulated time is now t + 0.5dt, where dt represents a whole time step between E or H frame updates. </span></p><p><span>Assuming a scale-invariant implementation (ie, all constants such as C, Epsilon0 and Mu0 are set to 1) the value for dx is calculated as 1/10th of the minimum lambda for any source within the domain in order to maintain stability. The temporal step value dt may be set to one half of the scalar value of dx in order to satisfy Courant stability requirements. </span><sup><a href="#cmnt4" id="cmnt_ref4">[d]</a></sup><sup><a href="#cmnt5" id="cmnt_ref5">[e]</a></sup><sup><a href="#cmnt6" id="cmnt_ref6">[f]</a></sup><sup><a href="#cmnt7" id="cmnt_ref7">[g]</a></sup><sup><a href="#cmnt8" id="cmnt_ref8">[h]</a></sup></p><p><span class="c22 c24">insert nice citation about Courant stability stuff</span></p><p><span>By repeatedly updating a matrix of E and H field values taking into account the material properties of the domain (indicating free space or refractive index of any waveguides or other geometry), and inducing changes in the E or H field corresponding to the effect of any sources, the FDTD algorithm convincingly simulates propagation of waves within the simulation domain. </span></p><p class="c16 c9"><span></span></p><h2 class="c16" id="h.ht5xrt6nbx6d"><span>Applications</span></h2><p><span>FDTD and related techniques such as finite element analysis play a crucial role in the design and evaluation of complex physical systems. For example, specification of an optical circuit may require the balancing of a large number of variables.</span></p><p><span>A recent example is a 3dB waveguide coupler &nbsp;which was designed at SMU using a commercial FDTD package from RSoft . &nbsp;</span></p><p><span></span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 369.00px; height: 343.00px;"><img alt="" src="images/image47.jpg" style="width: 369.00px; height: 343.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span></span></p><p><span>As can be seen in the preceding image, the circuit is a cross shape consisting of a substrate, intersecting waveguides and a &ldquo;mirror&rdquo; channel at the intersection point. In this case, some of variables in play were the dimensions and orientation of the mirror channel and waveguides, material properties such as indices of refraction, etc . If the splitter is intended to be integrated into a new design, additional parameters such as wavelength and amplitude of the incident light source must be considered.</span></p><p><span>Waveguide dimensions may range from nanometers to centimeters. Orientation of the mirror channel must be calculated along two independent axis. Light source parameters may range from from near-infrared to ultraviolet or beyond.</span></p><p><span>An exhaustive search of the solution domain</span><span>&nbsp;for this problem is complex and impractical using analytic methods. Even using high-performance compute clusters, FDTD simulation of a single circuit configuration can be prohibitively expensive. Simulation of dozens or hundreds of possible combinations, to say nothing of the nearly infinite permutations possible in a higher-dimension domain, may be impossible without the availability of a hyper-scale cluster, utilization of which may dramatically increase the cost of a design project.</span></p><p><span>In many cases, an engineer may guide this process by eliminating potential designs based on intuition and experience, and combining promising configurations to find an acceptable solution. However, this process can potentially ignore efficient, counter-intuitive solutions. Increases in simulation performance enable analysis of more configurations in less v time, increasing the probability of finding near-optimal solutions for a given design problem.</span></p><p><span>Another technique that has received attention in the field of numerical modeling is the use of genetic, or evolutionary, algorithms &nbsp;to generate and analyze solutions to complex modeling problems. This technique may require hundreds or thousands of iterations to find an acceptable solution. Current modeling tools may require hours or days to simulate a single configuration, in which case such an iterative approach becomes impractical.</span></p><p><span>A significant reduction in the required time to analyze a single configuration makes this approach a practical tool for numerical analysis of systems with many independent variables, allowing designers to consider a solution domain orders of magnitude larger than was previously possible.</span></p><p><span></span></p><h1 class="c16 c18" id="h.iubvjpskxvtg"><span></span></h1><hr style="page-break-before:always;display:none;"><h1 class="c16 c18" id="h.kvfvfnjgs2az"><span></span></h1><h1 class="c16" id="h.myuyxkr0zdpx"><span>Existing Solutions</span></h1><p><span>A number of commercial and open-source FDTD simulation packages are currently available and enjoy various levels of adoption within the optics community. This section details two such packages, and provides an overview of the relative strengths and weaknesses of CPU vs GPU-based simulation.</span></p><h2 id="h.sqw6ea69zd9z"><span>Meep (Massachusetts Institute of Technology)</span></h2><p><span>Meep is an open-source FDTD package commonly used in research and academia. While powerful and performant, its design presents some challenges for new users or those without a strong programming background.</span></p><p><span>Meep excels at simulating regular structures that can be described in terms of constructive solid geometry. Meep&rsquo;s scripting system allows these shapes to be combined using boolean operators so that more complex shapes can be modeled. However, this approach is not well-suited to describing the types of non-regular geometry frequently required in real-world optical circuit design. Complex curves, gaps, irregular dielectric gradients within a structure (such as a transition from core to clad layers in fiber-optic cable) require significant effort to generate. Meep&rsquo;s lack of an interactive visualizer also makes it difficult to identify and correct errors in model descriptions.</span></p><p><span></span></p><p><span>Users are required to provide material definitions in Scheme,</span><sup><a href="#ftnt3" id="ftnt_ref3">[3]</a></sup><span>&nbsp;an obscure programming language which does not easily facilitate the simulation of </span><span>complex, arbitrarily-shaped structures</span><sup><a href="#cmnt9" id="cmnt_ref9">[i]</a></sup><span>. Engineers seeking to utilize Meep must become familiar with Scheme and either adapt their designs to its limitations, or be capable of generating functional definitions of their domain through voxelization</span><sup><a href="#ftnt4" id="ftnt_ref4">[4]</a></sup><span>&nbsp;or parameterized surface definition. </span></p><p><span>While Meep provides a &ldquo;material function&rdquo; capability, which allows a script to provide unique dielectric properties for every point in the simulation domain, it is left to the user to generate this function and any underlying data sets. This requires either custom software or third-party tools, adding unnecessary complexity to the design and simulation process.</span></p><p><span>Additionally, as a CPU-based implementation, Meep cannot take advantage of the underutilized GPU resources that are present in many simulation platforms. </span></p><h2 id="h.6hjaryrm9bhx"><span>Problems with Existing Solutions</span></h2><p><span>Popular existing solutions such as those detailed above are strictly CPU-based. Modern compute devices such as GPUs and cell processors are inexpensive and efficient when applied to parallelizable numerical analysis techniques such as FDTD and finite element analysis.</span></p><p><span>A modern consumer-grade graphics card may offer upwards of 16000 processing cores that are designed to perform similar operations in parallel at high speed. While the design of these devices is ill-suited to general purpose computing in which cores are required to perform dissimilar operations in parallel, they perform well when applied to techniques such as FDTD, which is the primary focus of this paper.</span></p><p><span>These devices are becoming commonplace in desktop workstations and other hardware that facilities may not be using for numerical modeling. Such systems represent valuable processing cycles that are not currently being leveraged to improve the efficiency and effectiveness of numerical modeling. </span></p><h1 id="h.pl8gzqmqhr1z"><span>Device Architecture</span></h1><p><span>While GPUs offer vastly increased domain-specific processing capability when compared to CPUs, the two platforms each have their strengths and weaknesses. </span></p><h2 id="h.5n775691jlv4"><span>CPU</span></h2><p><span>Since their inception, CPUs have been designed as general-purpose compute devices, singularly focused on processing a single datum at a time. Their physical architecture, instruction sets and interface reflect this specificity. </span></p><p><span>CPU architecture differs greatly from that of GPUs. While both are often described as &ldquo;multi-core,&rdquo; a GPU core and a CPU core are very different things.</span></p><p><span>Each CPU core provides independent cache, registers and ALU. GPU cores, on the other hand, are organized into groups called &ldquo;warps.&rdquo; Each streaming processor comprises a single ALU, with separate registers for each core. The net effect of &nbsp;these architectures is that CPU cores may execute entirely different programs, effectively acting as distinct processors, while each GPU core within a warp must execute the same instructions, but with different data. (Thus the term SIMD: &ldquo;single instruction, multiple data.&rdquo;)</span></p><p><span>As with GPUs, memory bandwidth and access latency is a critical performance bottleneck. While the dedicated caches for each CPU core alleviate this problem, resource contention between cores requiring use of the L3 cache (and thus high-latency, low-bandwidth host memory) can prove detrimental to performance.</span></p><h2 id="h.7h886cyymjz6"><span>GPU</span></h2><p><span>GPU architecture varies greatly from that of the CPU. This divergence is a result of the history of GPUs and their primary application: real-time image generation in games and visualization applications. </span></p><p><span>Unlike the CPU, where each core is effectively a discrete processor, GPU cores are divided into collections sometimes called a &ldquo;warp&rdquo;, each of which operates in single-instruction, multiple-data SIMD</span><sup><a href="#ftnt5" id="ftnt_ref5">[5]</a></sup><span>&nbsp;fashion. This means that, within a warp, each thread must execute in lockstep with its neighbors. This has a number of benefits:</span></p><p><span class="c22"></span></p><p><span>A significant disadvantage of this design is that applications must work to ensure that threads within a warp avoid divergence in both memory accesses and execution.</span></p><p><span>Since the hardware implementation of a GPU core provides different data resources (registers, etc.), but only a single execution unit, per warp, all threads must execute the same instruction at the same time. When any thread in a warp follows a different execution path than its neighbors (as a result of branching control structures within the kernel code), all threads within a warp must execute all possible paths. Each thread then discards any results that are not relevant to itself. This can result in severe performance degradation.</span></p><p><span></span></p><p><span>An additional concern is data dependence and cache coherence. Given the large number of threads in operation and any given time, and the finite bandwidth between an execution core and global memory</span><span class="c22">&nbsp;</span><span>cache optimization is critical. Contention for resources such as global memory, due to limited bandwidth per core, and for global memory in general, can effectively cause each core to behave as if it is executing serially rather than in parallel. This can easily cause GPU-based code to run orders of magnitude slower than the traditional CPU version. </span></p><p><span>Despite these limitations, GPUs offer several advantages over CPUs which, if properly utilized, can provide dramatic performance increases. </span></p><h2 id="h.gopaxnobw6p4"><span>Summary</span></h2><p><span>Ultimately, it may be concluded that GPUs are best applied to processes which repeatedly perform identical (or sufficiently similar) operations on large data sets with little or no data-interdependence. As such, FDTD is a prime candidate for a GPU-centric implementation. </span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><h3 id="h.jlslp2i4kkkl"><span></span></h3><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><h1 id="h.f56ztlst4nd1"><span>Design Goals</span></h1><p><span></span></p><p><span>My simulator is structured as a simple command-line application which performs the following functions:</span></p><ul class="c32 lst-kix_7y1s6xen8as-0 start"><li class="c6"><span>Process scripts describing configuration data. For example:</span></li></ul><ul class="c32 lst-kix_7y1s6xen8as-1 start"><li class="c20"><span>source location(s) and characteristics such as wavelength and amplitude</span></li><li class="c20"><span>exit conditions (number of time steps to be calculated)</span></li><li class="c20"><span>output file format and location</span></li><li class="c20"><span>visualizer configuration</span></li></ul><ul class="c32 lst-kix_7y1s6xen8as-0"><li class="c6"><span>Load and process models defined in the Wavefront OBJ</span><sup><a href="#ftnt6" id="ftnt_ref6">[6]</a></sup><span>&nbsp;file format, typically exported from a modeling package such as Autodesk 3DSMAX. These models must indicate a triangle-based geometry describing any geometry present within the simulation domain, as well material properties of those items. (In my implementation, this is limited to the refractive index of a given material.)</span></li><li class="c6"><span>Allocate and initialize data structures describing E, H and material state of the simulation domain.</span></li><li class="c6"><span>Iteratively update all sources, E and H fields until the exit conditions are met.</span></li><li class="c6"><span>Optionally update the real-time visualizer, if active</span></li><li class="c6"><span>Generate reports in the forms of images and raw data dumps for further analysis and processing.</span></li><li class="c6"><span>Allocate and manage GPU-based resources (field arrays and compute kernels)</span></li></ul><p><span>A primary design goal was the ability to selectively enable and disable features such as visualization in order to optimize performance. As such, distinct componnets such as the simulation core and visualization subsystem were created as completely separate software libraries, with a third application coordinating their interaction. This provides several benefits, chief of which is the ability to attach a visualizer to a running simulation at any time in order to determine what progress has been made. The visualizer may then be detached in order to conserve resources that may be used to accelerate the FDTD loop.</span></p><h1 id="h.47f61bc31s73"><span>I</span><span>mplementation</span></h1><p><span></span></p><p><span>Although I created several implementations using different languages (C#, C++ and Python) and graphics systems (OpenGL and DirectX), the current version is a C++ application using NVIDIA CUDA for calculation and OpenGL for visualization via a custom rendering engine.</span></p><p><span>NVIDIA&rsquo;s CUDA toolkit includes a C++ preprocessor (nvcc). In Visual Studio,when a CUDA project is built, each source file is first processed by nvcc. That finds decorated functions, known as kernels, that are intended to be &nbsp;executed on the GPU. Kernels are compiled into GPU-friendly PTX. Calls to kernels from host (CPU) code are replaced with CUDA library calls to configure and execute the kernel. The resulting source is then passed to the Visual Studio C++ compiler.</span></p><p><span></span></p><p><span>In the code below, note the &ldquo;__global__&rdquo; decorator before each function definition. This indicates to nvcc that &nbsp;a function is a kernel, and should be converted to PTX. </span></p><p><span class="c19"></span></p><a id="t.142b46172bb85d01ec239255366241de23b588d4"></a><a id="t.2"></a><table class="c12"><tbody><tr class="c23"><td class="c40" colspan="1" rowspan="1"><p class="c1"><span class="c0">__global__ void UpdateEz(</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; dim3 threadOffset</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; )</span></p><p class="c1"><span class="c0">{</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; unsigned int x = threadOffset.x + blockIdx.x * blockDim.x + threadIdx.x;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; unsigned int y = threadOffset.y + blockIdx.y * blockDim.y + threadIdx.y;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; if (y &lt; 1 || x &lt; 1)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float cb = Cb-&gt;Data[y * Cb-&gt;Size.x + x];</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; unsigned int center = y * Ez-&gt;Size.x + x;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float hxBottom = Hx-&gt;Data[y * Hx-&gt;Size.x + x];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float hxTop =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hx-&gt;Data[(y - 1) * Hx-&gt;Size.x + x];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float dhx = (hxBottom - hxTop);</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">#ifdef USE_PML</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float ezyPsi &nbsp;= Ezy-&gt;Decay[y] * Ezy-&gt;Psi[center] + Ezy-&gt;Amp[y] * dhx;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Ezy-&gt;Psi[center] = ezyPsi;</span></p><p class="c1"><span class="c0">#endif</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float hyRight = &nbsp;Hy-&gt;Data[y * Hy-&gt;Size.x + x];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float hyLeft = &nbsp; Hy-&gt;Data[y * Hy-&gt;Size.x + x - 1];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float dhy = (hyLeft - hyRight);</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">#ifdef USE_PML</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float ezxPsi = Ezx-&gt;Decay[x] * Ezx-&gt;Psi[center] + Ezx-&gt;Amp[x] * dhy;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Ezx-&gt;Psi[center] = ezxPsi;</span></p><p class="c1"><span class="c0">#endif</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Ez-&gt;Data[center] = CA * Ez-&gt;Data[center] + cb * (dhy - dhx)</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">#ifdef USE_PML</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + cb * (ezxPsi - ezyPsi)</span></p><p class="c1"><span class="c0">#endif</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">__global__ void UpdateHx(dim3 threadOffset)</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; unsigned int x = threadOffset.x + blockIdx.x * blockDim.x + threadIdx.x;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; unsigned int y = threadOffset.y + blockIdx.y * blockDim.y + threadIdx.y;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; if (y &gt;= Ez-&gt;Size.y - 1)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; unsigned int hxOffset = y * Hx-&gt;Size.x + x;</span></p><p class="c1"><span class="c0">#ifdef USE_MAGNETIC_MATERIALS</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float db = Db-&gt;Data[y * Db-&gt;Size.x + x];</span></p><p class="c1"><span class="c0">#else</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; const float db = DbDefault;</span></p><p class="c1"><span class="c0">#endif</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; //float ezTop = Ez-&gt;Data[y * Ez-&gt;Size.x + x];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; //float ezBottom = Ez-&gt;Data[(y+1) * Ez-&gt;Size.x + x];</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float dEz = Ez-&gt;Data[(y+1) * Ez-&gt;Size.x + x] - Ez-&gt;Data[y * Ez-&gt;Size.x + x];</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float hx = DA * Hx-&gt;Data[hxOffset] - db * dEz;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">#ifdef USE_PML</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /// update boundaries</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float decay = Hxy-&gt;Decay[y];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float amp = Hxy-&gt;Amp[y];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float psi = Hxy-&gt;Psi[hxOffset];</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; psi = decay * psi + amp * dEz / Configuration-&gt;Dx;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; hx = hx - db * Configuration-&gt;Dx * psi;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Hxy-&gt;Psi[hxOffset] = psi;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">#endif</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Hx-&gt;Data[hxOffset] = hx;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">__global__ void UpdateHy(dim3 threadOffset)</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; unsigned int x = threadOffset.x + blockIdx.x * blockDim.x + threadIdx.x;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; unsigned int y = threadOffset.y + blockIdx.y * blockDim.y + threadIdx.y;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; if (x &gt;= Ez-&gt;Size.x - 1)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; unsigned int hyOffset = y * Hy-&gt;Size.x + x;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">#ifdef USE_MAGNETIC_MATERIALS</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float db = Db-&gt;Data[y * Db-&gt;Size.x + x];</span></p><p class="c1"><span class="c0">#else</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; const float db = DbDefault;</span></p><p class="c1"><span class="c0">#endif</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float ezLeft = Ez-&gt;Data[y * Ez-&gt;Size.x + x];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float ezRight = Ez-&gt;Data[y * Ez-&gt;Size.x + x + 1];</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float dEz = ezRight - ezLeft;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float hy = DA * Hy-&gt;Data[hyOffset] - db * (ezRight - ezLeft);</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">#ifdef USE_PML</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float psi = Hyx-&gt;Psi[hyOffset];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float decay = Hyx-&gt;Decay[x];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; float amp = Hyx-&gt;Amp[x];</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; psi = decay * psi + amp * dEz / Configuration-&gt;Dx;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; hy = hy - db * Configuration-&gt;Dx * psi;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Hyx-&gt;Psi[hyOffset] = psi;</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">#endif</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Hy-&gt;Data[hyOffset] = hy;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1 c9"><span class="c0"></span></p><p class="c1 c9"><span class="c0"></span></p></td></tr></tbody></table><p><span class="c19"></span></p><p><span></span></p><p><span></span></p><p><span></span></p><h2 id="h.f2gnbl9h7e4l"><span>Test Model Configuration</span></h2><p><span>For testing and validation purposes, a simulation comprising a plane wave source, dielectric slab with relative </span><img src="images/image07.png"><span>, and two monitors.</span></p><p><span>In the figure below, the plane wave source is represented by the red vertical line, while the incident and transmission monitors are represented by the vertical blue lines.</span></p><p><span>The green area represents the dielectric slab.</span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 156.00px;"><img alt="" src="images/image41.png" style="width: 624.00px; height: 156.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c24">Figure 1: Test model </span></p><h2 id="h.m8g0fnu5fwk6"><span>Testing Methodology</span></h2><p class="c14"><span>Testing was performed with a </span><img src="images/image08.png"><span>simulation. The simulation was first run with a relative </span><img src="images/image09.png"><span>to record the incident magnitude in absence of any reflective interfaces.</span></p><p class="c14"><span>The simulation was then run with </span><img src="images/image10.png"><span>in the dielectric slab area to record combined incidence and reflection, as well as transmittance within the dielectric. </span></p><p class="c14"><span>In a post-processing step, the reflective magnitude was found by subtracting the incident wave magnitude obtained from the first simulation from the combined incidence and reflection magnitudes from the second simulation:</span></p><p class="c14 c3"><img src="images/image11.png"></p><h3 id="h.o2i3awhojasy"><span>Validation </span></h3><p><span>Validation was performed by comparing the theoretical Fresnel coefficients for the test model with the time-averaged power (RMS) recorded during simulation.</span></p><h3 id="h.qtfbr0gx5o46"><span>Analytical Result</span></h3><p><span>In the test configuration, a normalized (</span><img src="images/image12.png"><span>) </span><img src="images/image08.png"><span>&nbsp;plane wave is normally incident upon a dielectric interface with</span><img src="images/image10.png"><span>.</span></p><p><span>Snell&rsquo;s law states that the ratio of the refractive indices of the media at an interface, along with the angle of incidence, determine the angle of transmittance, as illustrated by the following diagram. </span></p><p><span></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 436.58px; height: 251.00px;"><img alt="Snell&#39;s Law" src="images/image40.jpg" style="width: 436.58px; height: 251.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span></span></p><p><span>Mathematically, this relationship is expressed as:</span></p><p><span></span></p><p class="c3"><img src="images/image13.png"></p><p class="c9 c3"><span></span></p><p><span>In the test model, the refractive index </span><img src="images/image14.png"><span>, the index is calculated using the formula:</span></p><p><span></span></p><p class="c3"><img src="images/image15.png"></p><p class="c9 c3"><span></span></p><p><span>In our simulator, </span><img src="images/image16.png"><span>and </span><img src="images/image17.png"><span>are normalized to 1. Similarly, in the anisotropic media used in this case, </span></p><p class="c3"><img src="images/image18.png"><span>&nbsp;</span></p><p><span>Using </span><img src="images/image10.png"><span>gives </span></p><p class="c3"><img src="images/image19.png"></p><p class="c9 c3"><span></span></p><p><span>For a normally-incident plane wave, the incident and refraction angles are</span></p><p class="c3"><img src="images/image20.png"><span>&nbsp;and </span><img src="images/image21.png"></p><p class="c9 c21"><span></span></p><p class="c21"><span>Evaluating the Fresnel equations for the reflection and transmission coefficients for a </span><span class="c24">p</span><span>-polarized wave,</span></p><p class="c3"><img src="images/image22.png"></p><p class="c3"><img src="images/image23.png"></p><p><span>gives the coefficients</span></p><p class="c3"><img src="images/image24.png"></p><p class="c3"><img src="images/image25.png"></p><p><span></span></p><p><span>In this case, given a dielectric constant </span><img src="images/image10.png"><span>, the reflection and transmission coefficients are equal. </span></p><p><span></span></p><h3 id="h.444sb8v67ypi"><span>Numerical Result</span></h3><p><span>The observed steady-state output of the simulation for the baseline case (</span><img src="images/image26.png"><span>), is shown below:</span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 172.00px;"><img alt="" src="images/image50.png" style="width: 624.00px; height: 172.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span>The time-averaged (RMS) numerical output for the incident and transmitted monitors is</span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 352.00px;"><img alt="" src="images/image56.png" style="width: 624.00px; height: 352.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span></span></p><p><span>As expected, the incident and transmittance magnitudes equal the source magnitude, offset by the time it takes for the wave to propagate from the source to the monitors.</span></p><p><span>The observed output of the same simulation, executed with a dielectric constant </span><img src="images/image27.png"><span>, </span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 170.67px;"><img alt="" src="images/image44.png" style="width: 624.00px; height: 170.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span>Note the difference in </span><img src="images/image28.png"><span>once the wave enters the dielectric (green area). </span></p><p><span></span></p><p><span>This simulation produces the following raw (not normalized or smoothed) output:</span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 392.33px;"><img alt="" src="images/image55.png" style="width: 624.00px; height: 392.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span>The numerical time-averaged power for the monitors:</span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 316.00px;"><img alt="" src="images/image45.png" style="width: 624.00px; height: 316.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span></span></p><p><span>Subtracting the incident magnitude from the simulation with </span><img src="images/image29.png"><span>from the second simulation with </span><img src="images/image10.png"><span>gives the following (normalized) result:</span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 318.67px;"><img alt="" src="images/image54.png" style="width: 624.00px; height: 318.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span></span></p><p><span>In this case, the average of each of the relevant values are shown to be :</span></p><p class="c3"><img src="images/image30.png"></p><p class="c3"><img src="images/image31.png"></p><p class="c3"><img src="images/image32.png"></p><p><span></span></p><p><span>Given that conservation of energy requires:</span></p><p class="c3"><img src="images/image33.png"></p><p class="c9 c3"><span></span></p><p><span>The computed error of the computational result is:</span></p><p class="c9 c21"><span></span></p><p class="c3"><img src="images/image34.png"></p><p><span></span></p><p><span>Comparing to the numerically calculated analytical Fresnel coefficients,</span></p><p class="c3"><img src="images/image35.png"></p><p class="c3"><img src="images/image36.png"></p><p><span></span></p><p><span>Given these values, the error</span><sup><a href="#ftnt7" id="ftnt_ref7">[7]</a></sup><span>&nbsp;contribution of each component can be expressed as</span></p><p class="c3"><img src="images/image37.png"></p><p class="c9 c3"><span></span></p><p class="c3"><img src="images/image38.png"></p><h2 id="h.45n5ld8ynbzb"><span>Performance</span></h2><p><span>Metrics were calculated using domain sizes ranging from 128x64 to 8192x4096 over 5000 frames. (In this case, a frame represents a complete time step wherein both E and H fields are updated.) For benchmarking purposes, the real-time visualizer was disabled.</span></p><p><span></span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 428.00px;"><img alt="" src="images/image39.png" style="width: 624.00px; height: 428.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span>As the number of computational cells in the simulation domain increases, the required computation time increases linearly.</span></p><p><span></span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 600.00px; height: 371.00px;"><img alt="" src="images/image43.png" style="width: 600.00px; height: 371.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span>Note that the total throughput (represented in the following figure as &ldquo;cell&rdquo; operations per second) increases dramatically as the domain size increases, until the point where GPU initialization overhead is outweighed by computation time.</span></p><p><span></span></p><p><span>Comparing to Meep:</span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 650.00px; height: 361.00px;"><img alt="" src="images/image53.png" style="width: 731.59px; height: 388.50px; margin-left: -73.59px; margin-top: -27.50px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p><span>This gives a speedup ranging from 1.2: to 8:</span></p><p><span></span></p><p><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 607.13px; height: 328.50px;"><img alt="" src="images/image42.png" style="width: 676.51px; height: 417.40px; margin-left: -32.52px; margin-top: -33.61px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 id="h.41kzd4vlq6o2"><span>Future Work</span></h1><p><span class="c22">genetic algorithms, heterogeneous platforms, visualization, interactivity???</span></p><h1 id="h.ta42bg8umuhq"><span>Conclusions</span></h1><p><span class="c22">Duh.</span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p class="c9 c16"><span></span></p><p class="c16 c9"><span></span></p><p class="c16 c9"><span></span></p><p class="c16 c9"><span></span></p><p class="c16 c9"><span></span></p><p class="c16 c9"><span></span></p><p class="c16 c9"><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><p><span></span></p><div><p class="c41"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 680.27px; height: 46.13px;"><img alt="" src="images/image48.png" style="width: 680.27px; height: 46.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9 c3 c36"><span class="c27"></span></p><p class="c4 c3 c25"><span class="c17">Thesis presented by S. David Lively to the Electrical Engineering Department of the Lyle School of Engineering at Southern Methodist University in partial fulfillment of the requirements for the</span></p><p class="c3 c15"><span class="c17">degree of Masters of Science, Electrical Engineering</span></p><p class="c15 c3"><span class="c27">March 2016</span></p></div><hr class="c39"><div><p class="c4"><a href="#ftnt_ref1" id="ftnt1">[1]</a><span>&nbsp;Yee, Kane S. &quot;Numerical solution of initial boundary value problems involving Maxwell&rsquo;s equations in isotropic media.&quot; </span><span class="c24">IEEE Trans. Antennas Propag</span><span>&nbsp;14.3 (1966): 302-307.</span><sup><a href="#cmnt10" id="cmnt_ref10">[j]</a></sup></p></div><div><p class="c4"><a href="#ftnt_ref2" id="ftnt2">[2]</a><span>&nbsp;Luebke, David et al. &quot;GPGPU: general-purpose computation on graphics hardware.&quot; </span><span class="c24">Proceedings of the 2006 ACM/IEEE conference on Supercomputing</span><span>&nbsp;11 Nov. 2006: 208.</span></p></div><div><p class="c4"><a href="#ftnt_ref3" id="ftnt3">[3]</a><span>&nbsp;&quot;Meep Tutorial - AbInitio.&quot; 2005. 18 Jun. 2016 &lt;</span><span class="c5"><a class="c8" href="https://www.google.com/url?q=http://ab-initio.mit.edu/wiki/index.php/Meep_Tutorial&amp;sa=D&amp;ust=1462997725932000&amp;usg=AFQjCNE3wRfjv61eDJCpCHHn83nOMF-JKA">http://ab-initio.mit.edu/wiki/index.php/Meep_Tutorial</a></span><span>&gt;</span></p></div><div><p class="c4"><a href="#ftnt_ref4" id="ftnt4">[4]</a><span>&nbsp;Wang, Sidney W, and Arie E Kaufman. &quot;Volume sampled voxelization of geometric primitives.&quot; </span><span class="c24">Visualization, 1993. Visualization&#39;93, Proceedings., IEEE Conference on</span><span>&nbsp;25 Oct. 1993: 78-84.</span></p></div><div><p class="c4"><a href="#ftnt_ref5" id="ftnt5">[5]</a><span>&nbsp;Maresca, Massimo, and Hungwen Li. &quot;Connection autonomy in SIMD computers: a VLSI implementation.&quot; </span><span class="c24">Journal of Parallel and Distributed Computing</span><span>&nbsp;7.2 (1989): 302-320.</span></p></div><div><p class="c4"><a href="#ftnt_ref6" id="ftnt6">[6]</a><span>&nbsp;Wavefront OBJ is an industry standard, text-based file format with provisions for describing triangle- and quad-based geometry as well as extended properties such as refractive index.</span></p></div><div><p class="c4"><a href="#ftnt_ref7" id="ftnt7">[7]</a><span>&nbsp;Potential sources of error include numerical precision loss, energy loss into the PML boundary, numerical loss through the normalization and smoothing process and discretization error which could be addressed through sub-pixel averaging. </span></p></div><div class="c7"><p class="c1"><a href="#cmnt_ref1" id="cmnt1">[a]</a><span class="c26">Finish this up first. &nbsp;What&#39;s the story?</span></p></div><div class="c7"><p class="c1"><a href="#cmnt_ref2" id="cmnt2">[b]</a><span class="c26">Replace with vector art</span></p></div><div class="c7"><p class="c1"><a href="#cmnt_ref3" id="cmnt3">[c]</a><span class="c26">Clip the picture of Yee cell from the original paper and use it there. &nbsp;You then reference the source in the caption.</span></p></div><div class="c7"><p class="c1"><a href="#cmnt_ref4" id="cmnt4">[d]</a><span class="c26">The stability limit for a 3D cell is dt&lt;= dx/(c*sqrt(3)). &nbsp;The dx &lt; lambda/10 is more for numerical dispersion errors than stability.</span></p></div><div class="c7"><p class="c1"><a href="#cmnt_ref5" id="cmnt5">[e]</a><span class="c26">Nyquist? I think the sqrt(3) is really sqrt of sim dimensionality?</span></p></div><div class="c7"><p class="c1"><a href="#cmnt_ref6" id="cmnt6">[f]</a><span class="c26">The sqrt(3) is related to the dimensionality, I don&#39;t remember exactly how off the top of my head though. &nbsp;It&#39;s still not directly related to the numerical stability of the simulation though. &nbsp;You can run a simulation where dx &gt;= lambda/10 is true, and it will run fine. &nbsp;You&#39;re results will be inaccurate due to the wave not propagating correctly.</span></p></div><div class="c7"><p class="c1"><a href="#cmnt_ref7" id="cmnt7">[g]</a><span class="c26">Thanks for looking. &nbsp;</span></p><p class="c1"><span class="c26">&nbsp;</span></p><p class="c1"><span class="c26">Sent from my iPhone</span></p></div><div class="c7"><p class="c1"><a href="#cmnt_ref8" id="cmnt8">[h]</a><span class="c26">the stability limit for 3D cells is dt &gt; dx/(c*sqrt(3)) &nbsp;. &nbsp;The &#39;requirement&#39; for dx &lt; 1/10 lambda is more for numerical dispersion than stability. &nbsp;You will get large errors in how your waves propogate if your resolution is larger than lamdba/dx. &nbsp;Also, features smaller than ~1/10 of a wavelength don&#39;t affect a wave all that much so can often be ignored.</span></p></div><div class="c7"><p class="c1"><a href="#cmnt_ref9" id="cmnt9">[i]</a><span class="c26">Scheme isn&#39;t the only thing that makes it difficult to model complex shapes. &nbsp;Their programatic generation of material files makes real world and complex shapes very challenging to implement. &nbsp;I would showcase this a case where the tool was design for physicist studying general problem spaces as opposed to engineers looking at real world problems.</span></p></div><div class="c7"><p class="c1"><a href="#cmnt_ref10" id="cmnt10">[j]</a><span class="c26">I don&#39;t think this is the prefered reference format for a thesis. &nbsp;While not important now, make sure of this before you turn the thesis in</span></p></div></body></html>