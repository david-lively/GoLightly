\chapter{GoLightly} \label{ch:golightly}

GoLightly is the GPU-based FDTD simulator application that is the focus and product of this thesis. Written using a combination of C++, CUDA and OpenGL, it provides a lightweight yet complete FDTD solution.

\section{Goals}

GoLightly is intended to address deficiencies common to CPU-based solutions. In particular, it is designed to be fast, friendly and portable.


\begin{itemize}
	\item Fast. An iterative design process requires rapid feedback from the simulator. Long simulation times necessitated by existing solutions inhibit this process.
	\item Friendly. Definition of models and other simulation parameters should not require expertise in software development or quasi-proprietary scripting languages. 
	\item Portable. Ideally, the simulator should run on a high-end consumer grade laptop and support the most common desktop operating systems (Microsoft Windows and Apple OS X).  
\end{itemize}

To meet those goals, GoLightly takes advantage of the oft-underutilized programmable GPU available in common desktop and laptop computers, resulting in a dramatic speedup. Rather than relying on a proprietary model definition language or obscure, limited scripting system, we use industry-standard image and geometry file formats so that models may be defined using robust, familiar, readily-available tools. By building the software specifically for Microsoft Windows, we ensure that it is compatible with the most common desktop operating system. 

\section{Architecture}

GoLightly comprises three primary application blocks:

\begin{itemize}
	\item Model Processor \ref{sec:modelProcessor}
	\item Simulator \ref{sec:simulator}
	\item Visualizer \ref{sec:visualizer}
\end{itemize}


FLOWCHART HERE?

\subsection{Model Processor}\label{sec:modelProcessor}

The model processor (MP) is responsible for initialization of the simulator. When launching the simulator, a domain size and image file, containing a coded image of the desired dielectric, as well as a max $\epsilon$ are specified.

\begin{table}[h!]
	\centering
	\caption{Model processor inputs}
	\label{tab:modelProcessorInputs}
	\begin{tabular}{l | l | l | l}
		Symbol	& Data Type & Meaning & Typical value				\\
		\hline														\\
		Width	& int 		& Domain size in X & 1024				\\
		Height	& int 		& Domain size in Y & 1024				\\
		Media	& float 	& $\epsilon_{max}$ & 9						\\
		Model	& string	& Model definition stored as a bitmap & filename
	\end{tabular}
\end{table}

The MP allocates arrays to hold the dielectric properties for each Yee cell. These arrays are of the same dimensions as the domain, which may be different than the dimensions of the model. 

Once the model image is loaded, the MP iterates through each element in the dielectric array. (See \autoref{listing:modelFromImage})

For each element:

\begin{enumerate}
	\item Determine the normalized texel coordinate that corresponds to the current cell position	
	\item Read the red (R), green (G) and blue (B) color components from the image
	\item If $R > 128$, this texel is part of a source. Add the cell to the list of sources
	\item If $G > 0$, this texel has non-unity dielectric. Set ${C_b}_{i,j} = \epsilon_{max} * \frac{G}{255.0}$
	\item If $B > 0$, this texel is part of a monitor. Add its position to the monitor definition with ID = $B$
\end{enumerate}

\lstinputlisting[language=c++,caption=Generating a model from an image]{model-from-image.cpp}\label{listing:modelFromImage}

Once the dielectric, sources and monitors are derived from the model image, the model processor transfers control to the simulator.

\subsection{Simulator}\label{sec:simulator}

The simulator block implements the FDTD algorithm. Given the dielectric, source and monitor configurations from the model processor, the simulator initializes the GPU, transfers required data from host memory to the GPU, and begins the simulation loop.

For each loop iteration, the simulator launches a CUDA kernel to update all $E$ fields. Once the $E$ update is complete, the simulator launches kernels to update all $H$ fields.

Note that all $E$ updates occur simultaneously, as do all H fields. However, given the dependence between the $E$ and $H$ fields, the $E$ field update kernels must complete before the $H$ fields are updated.

The simulator repeats this operation until the application is closed, or the desired number of frames are completed. 

Finally, the completed field arrays are copied to the host from the GPU, and saved to disk in bitmap and CSV format for later analysis. 

\subsection{Visualizer}\label{sec:visualizer}


\section{Modeling approach}
\section{Implementation}
\section{Testing methodology}
\subsection{Test Model}
\subsection{Analytical Result}
\subsection{Numerical Result}
\subsection{Comparison}
\section{Additional Examples}
\subsection{Coupler}
\subsection{Splitter}

